# =============================================================================
# CORTEZ6 - AUDITORÍA DE BASE DE DATOS Y ARQUITECTURA
# Fecha: 2025-12-12
# Auditor: Claude Code (Arquitecto de Software / Experto en Base de Datos)
# =============================================================================
#
# RESUMEN EJECUTIVO:
# - 17 tablas analizadas
# - 45+ defectos identificados
# - 8 defectos CRÍTICOS (integridad referencial)
# - 15 defectos ALTOS (constraints faltantes)
# - 22 defectos MEDIOS (optimización/mejoras)
#
# TABLAS ANALIZADAS:
# 1. sessions, 2. cognitive_traces, 3. risks, 4. evaluations,
# 5. trace_sequences, 6. student_profiles, 7. activities, 8. users,
# 9. git_traces, 10. course_reports, 11. remediation_plans,
# 12. risk_alerts, 13. interview_sessions, 14. incident_simulations,
# 15. lti_deployments, 16. simulator_events, 17. lti_sessions
# =============================================================================


# =============================================================================
# SECCIÓN 1: INTEGRIDAD REFERENCIAL - FOREIGN KEYS FALTANTES
# Severidad: CRÍTICA
# Impacto: Datos huérfanos, inconsistencia referencial
# =============================================================================

FIX 1.1 [CRÍTICO] CourseReportDB.teacher_id sin FK constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~753
Problema: teacher_id es String(100) sin ForeignKey a users.id
Impacto: Reportes pueden referenciar teachers inexistentes
Solución:
```python
# ANTES:
teacher_id = Column(String(100), nullable=False, index=True)

# DESPUÉS:
teacher_id = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True, index=True)
teacher = relationship("UserDB", foreign_keys=[teacher_id])
```

FIX 1.2 [CRÍTICO] RemediationPlanDB.teacher_id sin FK constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~833
Problema: teacher_id es String(100) sin ForeignKey a users.id
Impacto: Planes de remediación pueden referenciar teachers inexistentes
Solución:
```python
# ANTES:
teacher_id = Column(String(100), nullable=False, index=True)

# DESPUÉS:
teacher_id = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True, index=True)
teacher = relationship("UserDB", foreign_keys=[teacher_id])
```

FIX 1.3 [CRÍTICO] RiskAlertDB.assigned_to sin FK constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~922
Problema: assigned_to es String(100) sin ForeignKey a users.id
Impacto: Alertas pueden asignarse a usuarios inexistentes
Solución:
```python
# ANTES:
assigned_to = Column(String(100), nullable=True)

# DESPUÉS:
assigned_to = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True, index=True)
assigned_to_user = relationship("UserDB", foreign_keys=[assigned_to])
```

FIX 1.4 [CRÍTICO] RiskAlertDB.acknowledged_by sin FK constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~928
Problema: acknowledged_by es String(100) sin ForeignKey a users.id
Solución:
```python
# ANTES:
acknowledged_by = Column(String(100), nullable=True)

# DESPUÉS:
acknowledged_by = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
acknowledged_by_user = relationship("UserDB", foreign_keys=[acknowledged_by])
```

FIX 1.5 [CRÍTICO] activity_id sin FK en múltiples tablas
----------------------------------------
Problema: Las siguientes tablas tienen activity_id sin FK constraint:
- CognitiveTraceDB.activity_id (línea ~196)
- RiskDB.activity_id (línea ~350)
- EvaluationDB.activity_id (línea ~412)
- TraceSequenceDB.activity_id (línea ~504)
- GitTraceDB.activity_id (línea ~688)
- CourseReportDB (no tiene activity_id, usa course_id)
- RiskAlertDB.activity_id (línea ~907)

Impacto: Trazas/riesgos/evaluaciones pueden referenciar actividades inexistentes
Solución: Agregar FK constraint a activities.activity_id
```python
activity_id = Column(String(100), ForeignKey("activities.activity_id", ondelete="SET NULL"), nullable=True, index=True)
```

Nota: SET NULL porque actividad puede archivarse y las trazas históricas deben preservarse.

FIX 1.6 [CRÍTICO] LTISessionDB.deployment_id sin ondelete
----------------------------------------
Archivo: backend/database/models.py
Línea: ~1196
Problema: FK sin ondelete puede causar errores al eliminar deployment
Solución:
```python
# ANTES:
deployment_id = Column(String(36), ForeignKey("lti_deployments.id"), nullable=False, index=True)

# DESPUÉS:
deployment_id = Column(String(36), ForeignKey("lti_deployments.id", ondelete="CASCADE"), nullable=False, index=True)
```

FIX 1.7 [CRÍTICO] LTISessionDB.session_id sin ondelete
----------------------------------------
Archivo: backend/database/models.py
Línea: ~1216
Problema: FK sin ondelete puede causar inconsistencias
Solución:
```python
# ANTES:
session_id = Column(String(36), ForeignKey("sessions.id"), nullable=True, index=True)

# DESPUÉS:
session_id = Column(String(36), ForeignKey("sessions.id", ondelete="SET NULL"), nullable=True, index=True)
```

FIX 1.8 [CRÍTICO] CourseReportDB.course_id sin FK constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~752
Problema: course_id no tiene tabla de referencia
Recomendación: Crear tabla CoursesDB para gestionar cursos
```python
class CourseDB(Base, BaseModel):
    __tablename__ = "courses"
    course_id = Column(String(100), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    institution_id = Column(String(100), nullable=True)
    academic_period = Column(String(50), nullable=True)  # "2025_1C"
    status = Column(String(20), default="active")
```


# =============================================================================
# SECCIÓN 2: CHECK CONSTRAINTS FALTANTES
# Severidad: ALTA
# Impacto: Valores inválidos en enums, datos inconsistentes
# =============================================================================

FIX 2.1 [ALTO] InterviewSessionDB.interview_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~974
Valores válidos: CONCEPTUAL, ALGORITHMIC, DESIGN, BEHAVIORAL
Solución:
```python
__table_args__ = (
    # ... existing indexes ...
    CheckConstraint(
        "interview_type IN ('CONCEPTUAL', 'ALGORITHMIC', 'DESIGN', 'BEHAVIORAL')",
        name='ck_interview_type_valid'
    ),
)
```

FIX 2.2 [ALTO] InterviewSessionDB.difficulty_level sin check constraint
----------------------------------------
Valores válidos: EASY, MEDIUM, HARD
Solución:
```python
CheckConstraint(
    "difficulty_level IN ('EASY', 'MEDIUM', 'HARD')",
    name='ck_interview_difficulty_valid'
)
```

FIX 2.3 [ALTO] IncidentSimulationDB.incident_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~1043
Valores válidos: API_ERROR, PERFORMANCE, SECURITY, DATABASE, DEPLOYMENT
Solución:
```python
CheckConstraint(
    "incident_type IN ('API_ERROR', 'PERFORMANCE', 'SECURITY', 'DATABASE', 'DEPLOYMENT')",
    name='ck_incident_type_valid'
)
```

FIX 2.4 [ALTO] IncidentSimulationDB.severity sin check constraint
----------------------------------------
Valores válidos: LOW, MEDIUM, HIGH, CRITICAL
Solución:
```python
CheckConstraint(
    "severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')",
    name='ck_incident_severity_valid'
)
```

FIX 2.5 [ALTO] ActivityDB.status sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~606
Valores válidos: draft, active, archived
Solución:
```python
CheckConstraint(
    "status IN ('draft', 'active', 'archived')",
    name='ck_activity_status_valid'
)
```

FIX 2.6 [ALTO] ActivityDB.difficulty sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~599
Valores válidos: INICIAL, INTERMEDIO, AVANZADO
Solución:
```python
CheckConstraint(
    "difficulty IS NULL OR difficulty IN ('INICIAL', 'INTERMEDIO', 'AVANZADO')",
    name='ck_activity_difficulty_valid'
)
```

FIX 2.7 [ALTO] RemediationPlanDB.plan_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~839
Valores válidos: tutoring, practice_exercises, conceptual_review, policy_clarification
Solución:
```python
CheckConstraint(
    "plan_type IN ('tutoring', 'practice_exercises', 'conceptual_review', 'policy_clarification')",
    name='ck_plan_type_valid'
)
```

FIX 2.8 [ALTO] RemediationPlanDB.status sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~859
Valores válidos: pending, in_progress, completed, cancelled
Solución:
```python
CheckConstraint(
    "status IN ('pending', 'in_progress', 'completed', 'cancelled')",
    name='ck_remediation_status_valid'
)
```

FIX 2.9 [ALTO] RiskAlertDB.alert_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~901
Valores válidos: critical_risk_surge, ai_dependency_spike, academic_integrity, pattern_anomaly
Solución:
```python
CheckConstraint(
    "alert_type IN ('critical_risk_surge', 'ai_dependency_spike', 'academic_integrity', 'pattern_anomaly')",
    name='ck_alert_type_valid'
)
```

FIX 2.10 [ALTO] RiskAlertDB.severity sin check constraint
----------------------------------------
Valores válidos: low, medium, high, critical
Solución:
```python
CheckConstraint(
    "severity IN ('low', 'medium', 'high', 'critical')",
    name='ck_alert_severity_valid'
)
```

FIX 2.11 [ALTO] RiskAlertDB.scope sin check constraint
----------------------------------------
Valores válidos: student, activity, course, institution
Solución:
```python
CheckConstraint(
    "scope IN ('student', 'activity', 'course', 'institution')",
    name='ck_alert_scope_valid'
)
```

FIX 2.12 [ALTO] RiskAlertDB.status sin check constraint
----------------------------------------
Valores válidos: open, acknowledged, investigating, resolved, false_positive
Solución:
```python
CheckConstraint(
    "status IN ('open', 'acknowledged', 'investigating', 'resolved', 'false_positive')",
    name='ck_alert_status_valid'
)
```

FIX 2.13 [ALTO] SimulatorEventDB.simulator_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~1161
Valores válidos: product_owner, scrum_master, tech_interviewer, incident_responder, client, devsecops
Solución:
```python
CheckConstraint(
    "simulator_type IN ('product_owner', 'scrum_master', 'tech_interviewer', 'incident_responder', 'client', 'devsecops')",
    name='ck_simulator_event_type_valid'
)
```

FIX 2.14 [ALTO] GitTraceDB.event_type sin check constraint
----------------------------------------
Archivo: backend/database/models.py
Línea: ~691
Valores válidos: commit, branch_create, merge, tag, etc.
Solución:
```python
CheckConstraint(
    "event_type IN ('commit', 'branch_create', 'branch_delete', 'merge', 'tag', 'revert', 'cherry_pick')",
    name='ck_git_event_type_valid'
)
```

FIX 2.15 [ALTO] Range constraints para campos numéricos
----------------------------------------
Campos que necesitan validación de rango:

CognitiveTraceDB.ai_involvement (línea ~215):
```python
CheckConstraint('ai_involvement >= 0 AND ai_involvement <= 1', name='ck_trace_ai_involvement_range')
```

EvaluationDB.overall_score (línea ~416):
```python
CheckConstraint('overall_score >= 0 AND overall_score <= 10', name='ck_eval_score_range')
```

EvaluationDB.ai_dependency_score (línea ~429):
```python
CheckConstraint('ai_dependency_score >= 0 AND ai_dependency_score <= 1', name='ck_eval_ai_dep_range')
```

TraceSequenceDB.ai_dependency_score (línea ~513):
```python
CheckConstraint('ai_dependency_score >= 0 AND ai_dependency_score <= 1', name='ck_seq_ai_dep_range')
```

StudentProfileDB.average_ai_dependency (línea ~549):
```python
CheckConstraint('average_ai_dependency >= 0 AND average_ai_dependency <= 1', name='ck_profile_ai_dep_range')
```

InterviewSessionDB.evaluation_score (línea ~1002):
```python
CheckConstraint('evaluation_score IS NULL OR (evaluation_score >= 0 AND evaluation_score <= 1)', name='ck_interview_score_range')
```


# =============================================================================
# SECCIÓN 3: DENORMALIZACIÓN Y REDUNDANCIA DE DATOS
# Severidad: MEDIA
# Impacto: Inconsistencia potencial, mayor uso de almacenamiento
# =============================================================================

FIX 3.1 [MEDIO] student_id y activity_id redundantes
----------------------------------------
Problema: Múltiples tablas tienen student_id y activity_id que ya existen en SessionDB:
- CognitiveTraceDB (líneas ~195-196)
- RiskDB (líneas ~349-350)
- EvaluationDB (líneas ~411-412)
- TraceSequenceDB (líneas ~503-504)
- GitTraceDB (líneas ~687-688)
- SimulatorEventDB (línea ~1160)
- InterviewSessionDB (líneas ~970-971)
- IncidentSimulationDB (líneas ~1039-1040)

Análisis:
- PRO: Permite queries sin JOIN a sessions (mejor performance)
- CON: Riesgo de inconsistencia si session.student_id != trace.student_id

Recomendación:
1. OPCIÓN A (Mantener denormalización + validación):
   Agregar trigger o constraint para validar consistencia:
   ```sql
   CREATE OR REPLACE FUNCTION validate_trace_session_consistency()
   RETURNS TRIGGER AS $$
   BEGIN
       IF NEW.student_id != (SELECT student_id FROM sessions WHERE id = NEW.session_id) THEN
           RAISE EXCEPTION 'student_id mismatch with session';
       END IF;
       RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;
   ```

2. OPCIÓN B (Eliminar redundancia - breaking change):
   Remover student_id y activity_id de tablas hijas, usar JOIN cuando sea necesario.
   No recomendado para MVP por impacto en queries existentes.

FIX 3.2 [MEDIO] JSON arrays en lugar de tablas relacionales
----------------------------------------
Las siguientes columnas usan JSON arrays para almacenar IDs de otras entidades:

TraceSequenceDB.trace_ids (línea ~517):
- Almacena lista de CognitiveTrace IDs
- Problema: Sin integridad referencial, traces pueden eliminarse dejando IDs huérfanos
- Solución (documentada en código): Crear tabla trace_sequence_traces para many-to-many

RiskDB.trace_ids (línea ~361):
- Almacena lista de trace IDs como evidencia
- Problema: No hay FK, traces pueden eliminarse sin actualizar la lista

RemediationPlanDB.trigger_risks (línea ~836):
- Almacena lista de Risk IDs
- Problema: Riesgos resueltos o eliminados quedan como referencias rotas

RiskAlertDB.evidence (línea ~913):
- Almacena referencias a risks/sessions/traces
- Problema: Sin validación de integridad

Recomendación futura: Crear tablas de asociación para relaciones many-to-many
```python
class RiskTraceAssociation(Base):
    __tablename__ = "risk_traces"
    risk_id = Column(String(36), ForeignKey("risks.id", ondelete="CASCADE"), primary_key=True)
    trace_id = Column(String(36), ForeignKey("cognitive_traces.id", ondelete="CASCADE"), primary_key=True)
```


# =============================================================================
# SECCIÓN 4: TIPOS DE DATOS E INCONSISTENCIAS
# Severidad: MEDIA
# Impacto: Problemas de storage, inconsistencia, performance
# =============================================================================

FIX 4.1 [MEDIO] Inconsistencia en longitud de IDs
----------------------------------------
Problema: Diferentes longitudes para campos similares:
- user_id: String(36) en algunas tablas, String(100) en otras
- student_id: String(100) en todas las tablas
- session_id: String(36) (correcto para UUID)
- activity_id: String(100)
- teacher_id: String(100) o String(36)

Solución: Estandarizar:
- UUIDs (session_id, user_id): String(36)
- IDs de negocio (student_id, activity_id): String(100)
- Documentar estándar en CLAUDE.md

FIX 4.2 [MEDIO] String(36) vs UUID nativo
----------------------------------------
Problema: PostgreSQL tiene tipo UUID nativo más eficiente
- String(36) usa 36 bytes + overhead
- UUID nativo usa 16 bytes, mejor indexación

Solución (solo PostgreSQL):
```python
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy import String

class UUIDCompatible(TypeDecorator):
    """UUID que usa tipo nativo en PostgreSQL y String en SQLite"""
    impl = String(36)
    cache_ok = True

    def load_dialect_impl(self, dialect):
        if dialect.name == 'postgresql':
            return dialect.type_descriptor(PG_UUID(as_uuid=True))
        return dialect.type_descriptor(String(36))
```

FIX 4.3 [MEDIO] Float vs Numeric para scores
----------------------------------------
Problema: Float tiene problemas de precisión con decimales
Campos afectados:
- ai_involvement, ai_dependency_score, overall_score, evaluation_score

Solución: Usar Numeric para precisión exacta
```python
from sqlalchemy import Numeric

ai_involvement = Column(Numeric(4, 3), default=0.0)  # 0.000 a 1.000
overall_score = Column(Numeric(4, 2), nullable=False)  # 0.00 a 10.00
```

FIX 4.4 [MEDIO] DateTime sin timezone explícito
----------------------------------------
Problema: Las columnas DateTime no especifican timezone
- _utc_now() retorna datetime con timezone
- Column DateTime puede perder info de TZ en algunas configuraciones

Solución:
```python
from sqlalchemy import DateTime
from sqlalchemy.dialects.postgresql import TIMESTAMP

# Usar TIMESTAMP WITH TIME ZONE en PostgreSQL
created_at = Column(DateTime(timezone=True), default=_utc_now, nullable=False)
```


# =============================================================================
# SECCIÓN 5: ÍNDICES Y OPTIMIZACIÓN
# Severidad: MEDIA
# Impacto: Performance de queries
# =============================================================================

FIX 5.1 [MEDIO] Índices redundantes en SessionDB
----------------------------------------
Archivo: backend/database/models.py
Problema: Posible redundancia entre índices:
- idx_session_student_activity (student_id, activity_id)
- idx_student_status (student_id, status)

Análisis: No son redundantes, cubren diferentes queries. OK.

FIX 5.2 [MEDIO] Falta índice en CourseReportDB
----------------------------------------
Problema: No hay índice compuesto para teacher_id + course_id
Solución:
```python
Index('idx_report_teacher_course', 'teacher_id', 'course_id'),
```

FIX 5.3 [MEDIO] Falta índice parcial para resolved=false
----------------------------------------
Problema: Queries frecuentes de "riesgos no resueltos" escanean toda la tabla
Solución (PostgreSQL):
```python
Index('idx_risk_unresolved', 'session_id', 'risk_level',
      postgresql_where=text("resolved = false"))
```

FIX 5.4 [MEDIO] Falta índice para RiskAlertDB.detected_at
----------------------------------------
Problema: Queries de alertas recientes no tienen índice óptimo
Solución:
```python
Index('idx_alert_detected_desc', 'detected_at', postgresql_ops={'detected_at': 'DESC'})
```

FIX 5.5 [MEDIO] Índices GIN no funcionan en SQLite
----------------------------------------
Problema: Los índices GIN para JSONB solo funcionan en PostgreSQL
Archivos afectados: CognitiveTraceDB, UserDB
Nota: Ya documentado con postgresql_using='gin', ignorado en SQLite. OK.


# =============================================================================
# SECCIÓN 6: TABLAS Y FEATURES FALTANTES
# Severidad: MEDIA-BAJA
# Impacto: Funcionalidad incompleta
# =============================================================================

FIX 6.1 [MEDIO] No existe tabla InteractionDB
----------------------------------------
Problema: CLAUDE.md menciona InteractionDB pero no existe en models.py
Análisis: Las interacciones se almacenan como CognitiveTraceDB con interaction_type
Recomendación: Documentar esta decisión de diseño o crear tabla dedicada

Opción A (Documentar): Actualizar CLAUDE.md indicando que interacciones = traces
Opción B (Crear tabla):
```python
class InteractionDB(Base, BaseModel):
    """Interacciones estudiante-IA (subset simplificado de traces)"""
    __tablename__ = "interactions"

    session_id = Column(String(36), ForeignKey("sessions.id", ondelete="CASCADE"), nullable=False, index=True)
    user_id = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    prompt = Column(Text, nullable=False)
    response = Column(Text, nullable=True)
    context = Column(JSON, default=dict)

    # Linked N4 trace for full cognitive data
    trace_id = Column(String(36), ForeignKey("cognitive_traces.id", ondelete="SET NULL"), nullable=True)
```

FIX 6.2 [MEDIO] No existe tabla de Audit Log
----------------------------------------
Problema: No hay registro de cambios para compliance/auditoría
Recomendación:
```python
class AuditLogDB(Base, BaseModel):
    """Log de auditoría para cambios críticos"""
    __tablename__ = "audit_logs"

    entity_type = Column(String(50), nullable=False, index=True)  # 'session', 'risk', etc.
    entity_id = Column(String(36), nullable=False, index=True)
    action = Column(String(20), nullable=False)  # 'create', 'update', 'delete'

    user_id = Column(String(36), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    old_values = Column(JSON, nullable=True)
    new_values = Column(JSON, nullable=True)

    ip_address = Column(String(45), nullable=True)  # IPv6 compatible
    user_agent = Column(String(500), nullable=True)
```

FIX 6.3 [BAJO] No existe tabla CourseDB
----------------------------------------
Problema: course_id se usa en CourseReportDB y RiskAlertDB sin tabla de referencia
Ver FIX 1.8 para solución propuesta

FIX 6.4 [BAJO] Soft Delete no implementado
----------------------------------------
Problema: SessionDB menciona soft delete como mejora futura pero no está implementado
Impacto: No hay recuperación de datos eliminados, no hay audit trail completo
Recomendación (para futuro):
```python
# Agregar a BaseModel:
deleted_at = Column(DateTime, nullable=True, index=True)

# Modificar queries con filtro:
.filter(Model.deleted_at.is_(None))
```


# =============================================================================
# SECCIÓN 7: RELACIONES Y BACK_POPULATES
# Severidad: MEDIA
# Impacto: Navegación bidireccional, consistencia ORM
# =============================================================================

FIX 7.1 [MEDIO] CourseReportDB sin relación a UserDB
----------------------------------------
Problema: teacher_id no tiene relationship definida
Solución: Ver FIX 1.1

FIX 7.2 [MEDIO] RemediationPlanDB sin relación a UserDB
----------------------------------------
Problema: teacher_id no tiene relationship definida
Solución: Ver FIX 1.2

FIX 7.3 [MEDIO] UserDB falta back_populates para nuevas relaciones
----------------------------------------
Si se implementan FIX 1.1-1.4, actualizar UserDB:
```python
# Agregar a UserDB:
course_reports = relationship("CourseReportDB", back_populates="teacher", foreign_keys="CourseReportDB.teacher_id")
remediation_plans = relationship("RemediationPlanDB", back_populates="teacher", foreign_keys="RemediationPlanDB.teacher_id")
assigned_alerts = relationship("RiskAlertDB", back_populates="assigned_to_user", foreign_keys="RiskAlertDB.assigned_to")
```


# =============================================================================
# SECCIÓN 8: PERFORMANCE Y ESCALABILIDAD
# Severidad: MEDIA-BAJA
# Impacto: Performance a largo plazo
# =============================================================================

FIX 8.1 [BAJO] Sin estrategia de particionamiento
----------------------------------------
Problema: Tablas de alto volumen crecerán sin límite
Tablas afectadas: cognitive_traces, simulator_events, git_traces

Recomendación futura (PostgreSQL):
```sql
-- Particionar cognitive_traces por fecha
CREATE TABLE cognitive_traces (
    ...
) PARTITION BY RANGE (created_at);

CREATE TABLE cognitive_traces_2025_q1 PARTITION OF cognitive_traces
    FOR VALUES FROM ('2025-01-01') TO ('2025-04-01');
```

FIX 8.2 [BAJO] JSON columns pueden crecer indefinidamente
----------------------------------------
Problema: Columnas JSONB en CognitiveTraceDB (6 dimensiones N4) pueden crecer
Campos afectados:
- semantic_understanding
- algorithmic_evolution
- cognitive_reasoning
- interactional_data
- ethical_risk_data
- process_data

Recomendación: Establecer límites en aplicación o usar CHECK constraint con función
```python
# En aplicación, validar tamaño antes de guardar
MAX_JSON_SIZE = 65536  # 64KB
if len(json.dumps(trace.semantic_understanding)) > MAX_JSON_SIZE:
    raise ValueError("semantic_understanding exceeds maximum size")
```

FIX 8.3 [BAJO] Sin archivado de datos históricos
----------------------------------------
Problema: No hay estrategia para archivar sesiones/trazas antiguas
Recomendación: Implementar política de retención
1. Crear tablas _archive para datos >1 año
2. Job periódico para mover datos antiguos
3. Comprimir datos archivados


# =============================================================================
# SECCIÓN 9: SEGURIDAD
# Severidad: MEDIA
# Impacto: Protección de datos sensibles
# =============================================================================

FIX 9.1 [MEDIO] hashed_password visible en to_dict()
----------------------------------------
Archivo: backend/database/base.py
Problema: BaseModel.to_dict() incluye hashed_password
Solución: Filtrar campos sensibles
```python
SENSITIVE_FIELDS = {'hashed_password', 'launch_token'}

def to_dict(self) -> Dict[str, Any]:
    result = {}
    for column in self.__table__.columns:
        if column.name in SENSITIVE_FIELDS:
            continue
        value = getattr(self, column.name)
        if isinstance(value, datetime):
            value = value.isoformat()
        result[column.name] = value
    return result
```

FIX 9.2 [BAJO] LTISessionDB.launch_token en texto plano
----------------------------------------
Problema: JWT token de LTI se almacena sin cifrar
Recomendación: Considerar cifrado at-rest para tokens sensibles


# =============================================================================
# SECCIÓN 10: DOCUMENTACIÓN Y MANTENIBILIDAD
# Severidad: BAJA
# Impacto: Facilidad de mantenimiento
# =============================================================================

FIX 10.1 [BAJO] Docstrings incompletos en modelos nuevos
----------------------------------------
Modelos con documentación mínima:
- SimulatorEventDB
- LTISessionDB

Recomendación: Agregar docstrings con:
- Propósito del modelo
- Relaciones clave
- Queries frecuentes

FIX 10.2 [BAJO] Comentarios de schema JSON desactualizados
----------------------------------------
Problema: Los comentarios JSON en modelos pueden quedar desactualizados
Recomendación: Mover schemas JSON a archivo separado o usar JSONSchema validation


# =============================================================================
# RESUMEN DE PRIORIDADES PARA IMPLEMENTACIÓN
# =============================================================================

FASE 1 - CRÍTICOS (Integridad referencial):
- FIX 1.1-1.8: Foreign keys faltantes
  Impacto: Previene datos huérfanos
  Esfuerzo: Medio (requiere migración)

FASE 2 - ALTOS (Validación de datos):
- FIX 2.1-2.15: Check constraints para enums y rangos
  Impacto: Previene datos inválidos
  Esfuerzo: Bajo (SQL simple)

FASE 3 - MEDIOS (Optimización):
- FIX 4.1-4.4: Tipos de datos
- FIX 5.1-5.5: Índices
- FIX 7.1-7.3: Relaciones
  Impacto: Mejor performance y consistencia
  Esfuerzo: Medio

FASE 4 - BAJOS (Mejoras futuras):
- FIX 6.1-6.4: Tablas faltantes
- FIX 8.1-8.3: Escalabilidad
- FIX 9.1-9.2: Seguridad
  Impacto: Preparación para producción
  Esfuerzo: Alto


# =============================================================================
# SCRIPT DE MIGRACIÓN PROPUESTO
# =============================================================================

# Archivo: backend/database/migrations/add_cortez6_fixes.py
#
# Cambios incluidos:
# - FKs faltantes (FIX 1.1-1.8)
# - Check constraints (FIX 2.1-2.15)
# - Índices adicionales (FIX 5.2-5.4)
#
# Ejecutar con: python -m backend.database.migrations.add_cortez6_fixes


# =============================================================================
# FIN DEL AUDIT CORTEZ6
# =============================================================================
